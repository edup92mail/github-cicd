name: module_terraform
on:
  workflow_call:
    inputs:
      Path:
        required: true
        type: string
      Runner:
        required: false
        type: string
        default: "ubuntu-latest"
      Stage:
        required: true
        type: string
      Environment:
        required: true
        type: string
      ExtraVars:
        required: false
        type: string
        default: "{}"
    outputs:
      TerraformOutput:
        value: ${{ jobs.Terraform.outputs.TerraformOutput }}
        
jobs:

  ParseConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Validate required files
      run: |
        ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
        required_files=(
          main.tf
          providers.tf
          backend.tf
          outputs.tf
          cicd.json
          project.json
          variables.tf
          ./environments/$ENVIRONMENT.tfvars.json
          ./environments/$ENVIRONMENT.tf
        )
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] || { echo "‚ùå Missing required file: $file"; exit 1; }
        done
        echo "‚úÖ All required files are present"
    - name: Validate minimal keys in cicd.json
      run: |
        VARIABLES_FILE="cicd.json"
        REQUIRED_KEYS=(
          ".Project"
          ".Region"
          ".Role"
          ".BackendBucket"
        )
        for key in "${REQUIRED_KEYS[@]}"; do
          value=$(jq -r "$key // empty" "$VARIABLES_FILE")
          if [[ -z "$value" || "$value" == "null" ]]; then
            echo "‚ùå ERROR: Missing key $key" ; exit 1
          fi
        done
        echo "‚úÖ All required Keys exists"
    - name: Validate minimal keys in project.json
      run: |
        VARIABLES_FILE="project.json"
        REQUIRED_KEYS=(
          ".Network"
          ".Ec2"
        )
        for key in "${REQUIRED_KEYS[@]}"; do
          value=$(jq -r "$key // empty" "$VARIABLES_FILE")
          if [[ -z "$value" || "$value" == "null" ]]; then
            echo "‚ùå ERROR: Missing key $key" ; exit 1
          fi
        done
        echo "‚úÖ All required Keys exists"
    - name: Validate Project, Repo, Stage and Environment format
      run: |
        VARIABLES_FILE="cicd.json"
        PROJECT=$(jq -r '.Project' "$VARIABLES_FILE")
        ENVIRONMENT="${{ inputs.Environment }}"
        STAGE="${{ inputs.Stage }}"

        # Validar que .Project comience con may√∫scula
        if [[ ! "$PROJECT" =~ ^[A-Z] ]]; then
          echo "‚ùå PROJECT must start with a capital letter (actual: \"$PROJECT\")"
          exit 1
        fi

        # Validar que Environment sea solo "Prod" o "Dev"
        if [[ "$ENVIRONMENT" != "Prod" && "$ENVIRONMENT" != "Dev" ]]; then
          echo "‚ùå Invalid Environment: (actual: \"$ENVIRONMENT\")"
          exit 1
        fi

        # Validar que Stage sea solo "Workload" o "Concept"
        if [[ "$STAGE" != "Workload" && "$STAGE" != "Concept" ]]; then
          echo "‚ùå Invalid Stage: (actual: \"$STAGE\")"
          exit 1
        fi

        echo "‚úÖ Project Name '$PROJECT' is valid"
        echo "‚úÖ Environment '$ENVIRONMENT' is valid"
        echo "‚úÖ Stage '$STAGE' is valid"
  ExtractConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Load CiCd Data
        id: CiCdJson
        run: |
          VARIABLES_FILE="cicd.json"
          PROJECT=$(jq -r '.Project' "$VARIABLES_FILE")
          REGION=$(jq -r '.Region' "$VARIABLES_FILE")
          ROLE=$(jq -r '.Role' "$VARIABLES_FILE")
          BACKENDBUCKET=$(jq -r '.BackendBucket' "$VARIABLES_FILE")
          DEPLOYKEYS=$(jq -c '.DeployKeys' "$VARIABLES_FILE")
          echo "PROJECT=$PROJECT" >> $GITHUB_OUTPUT
          echo "REPO=$REPO" >> $GITHUB_OUTPUT
          echo "REGION=$REGION" >> $GITHUB_OUTPUT
          echo "ROLE=$ROLE" >> $GITHUB_OUTPUT
          echo "BACKENDBUCKET=$BACKENDBUCKET" >> $GITHUB_OUTPUT
          echo "DEPLOYKEYS=$DEPLOYKEYS" >> $GITHUB_OUTPUT
      - name: Load project.json
        id: VariablesJson
        run: |
          VARIABLES_FILE="project.json"
          JSON=$(jq -c '.' "$VARIABLES_FILE")
          echo "JSON=$JSON" >> $GITHUB_OUTPUT
    outputs:
      VariablesJson: ${{ steps.VariablesJson.outputs.JSON }}
      Project: ${{ steps.CiCdJson.outputs.PROJECT }}
      CiCdRegion: ${{ steps.CiCdJson.outputs.REGION }}
      CiCdRole: ${{ steps.CiCdJson.outputs.ROLE }}
      CiCdBackendBucket: ${{ steps.CiCdJson.outputs.BACKENDBUCKET }}
      CiCdDeployKeys: ${{ steps.CiCdJson.outputs.DEPLOYKEYS }}

  ParseSShKey:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig]
    steps:
      - name: Validate Deploy Keys
        id: LoadDeployKeys
        run: |
          DEPLOYKEYS='${{ needs.ExtractConfig.outputs.CiCdDeployKeys }}'
          mkdir -p deploykeys
          for ENTRY in $(echo "$DEPLOYKEYS" | jq -c 'to_entries[]'); do
            NAME=$(echo "$ENTRY" | jq -r '.key')
            KEY_B64=$(echo "$ENTRY" | jq -r '.value')
            echo "üîç Validating key: $NAME"
            KEY=$(echo "$KEY_B64" | base64 -d 2>/dev/null || true)
            if echo "$KEY" | grep -q "PRIVATE KEY"; then
              echo "‚úÖ $NAME is valid"
              echo "$KEY" > "deploykeys/${NAME}.pem"
              chmod 600 "deploykeys/${NAME}.pem"
            else
              echo "‚ùå $NAME is invalid"
              exit 1
            fi
          done
          echo "üî¢ Found $COUNT valid keys"
      - name: Upload Deploy Keys
        uses: actions/upload-artifact@v4
        with:
          name: DeployKeys
          path: deploykeys/
      - name: Validate Keypairs
        run: |
          KEYPAIRS=$(echo '${{ needs.ExtractConfig.outputs.VariablesJson }}' | jq -r '.Ec2.KeyPairs | keys[]')
          for KEY in $KEYPAIRS; do
            echo "üîë Validando clave: $KEY"
            BASE64_KEY=$(echo '${{ needs.ExtractConfig.outputs.VariablesJson }}' | jq -r ".Ec2.KeyPairs[\"$KEY\"]")
            echo "$BASE64_KEY" | base64 -d > decoded_key 2>/dev/null
            if ssh-keygen -l -f decoded_key >/dev/null 2>&1; then
              echo "‚úÖ $KEY is valid"
            else
              echo "‚ùå $KEY is invalid"
              exit 1
            fi
          done
          rm -f decoded_key

  CreateTfFiles:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig, ParseSShKey]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Generate backend.tfbackend
        run: |
          cat <<EOF > backend.tfbackend
            bucket = "${{ needs.ExtractConfig.outputs.CiCdBackendBucket }}"
            key    = "${{ format('{0}{1}.tfstate', needs.ExtractConfig.outputs.Project, inputs.Stage) }}"
            region = "${{ needs.ExtractConfig.outputs.CiCdRegion }}"
          EOF
      - name: Create empty tfvars.json
        run: echo "{}" > tfvars.json
      - name: Append Project Name String > tfvars.json
        run: |
          jq --arg PROJECT "${{ needs.ExtractConfig.outputs.Project }}" '.Tags += {Project: $PROJECT}' tfvars.json > tmp.json && mv tmp.json tfvars.json
      - name: Append Repo String > tfvars.json
        run: |
          jq --arg Repo "$(basename "$GITHUB_REPOSITORY")" '.Tags += {Repo: $Repo}' tfvars.json > tmp.json && mv tmp.json tfvars.json
      - name: Append Stage String > tfvars.json
        run: |
          jq --arg stage "${{ inputs.Stage }}" '.Tags += {Stage: $stage}' tfvars.json > tmp.json && mv tmp.json tfvars.json
      - name: Append project.json > tfvars.json
        run: |
          VARS='${{ needs.ExtractConfig.outputs.VariablesJson }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' tfvars.json <(echo "$VARS") > tmp.json && mv tmp.json tfvars.json
          echo "‚úÖ $added_count variables added from Variables Project to tfvars.json"
      - name: Append environment variables > tfvars.json
        run: |
          ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
          VARS="./environments/$ENVIRONMENT.tfvars.json"
          added_count=$(jq 'keys | length' "$VARS")
          jq -s '.[0] * .[1]' tfvars.json "$VARS" > tmp.json && mv tmp.json tfvars.json
          echo "‚úÖ $added_count variables added from $VARS to tfvars.json"
      - name: Append ENVIRONMENT.tf to root variables.tf
        run: |
          ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
          VAR_FILE="./environments/${ENVIRONMENT}.tf"
          TARGET_FILE="variables.tf"
          echo "‚úÖ Appending $VAR_FILE to $TARGET_FILE"
          echo -e "\n\n" >> "$TARGET_FILE"
          cat "$VAR_FILE" >> "$TARGET_FILE"
      - name: Append inputs.ExtraVars > tfvars.json
        run: |
          VARS='${{ inputs.ExtraVars }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' tfvars.json <(echo "$VARS") > tmp.json && mv tmp.json tfvars.json
          echo "‚úÖ $added_count variables added from inputs.ExtraVars to tfvars.json"
      - name: Upload Terraform config files
        uses: actions/upload-artifact@v4
        with:
          name: TfFiles
          path: |
            backend.tfbackend
            tfvars.json
            variables.tf

  Apply:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig, ParseSShKey, CreateTfFiles]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Configure AWS credentials from OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.ExtractConfig.outputs.CiCdRole }}
          aws-region: ${{ needs.ExtractConfig.outputs.CiCdRegion }}
      - name: Download Terraform config files
        uses: actions/download-artifact@v4
        with:
          name: TfFiles
      - name: Download DeployKeys
        uses: actions/download-artifact@v4
        with:
          name: DeployKeys
          path: ./deploykeys
      - name: Read all private keys into env var
        id: read_ssh_keys
        run: |
          KEY_DATA=""
          for f in deploykeys/*.pem; do
            [ -f "$f" ] || continue
            KEY=$(cat "$f")
            KEY_DATA="${KEY_DATA}${KEY}"$'\n\n'
          done
          echo "ALL_SSH_KEYS<<EOF" >> $GITHUB_ENV
          echo "$KEY_DATA" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: Load SSH keys into agent
        if: env.ALL_SSH_KEYS != ''
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.ALL_SSH_KEYS }}
      - name: Terraform Init
        run: terraform init -backend-config=backend.tfbackend
      - name: Terraform Validate
        run: terraform validate
        timeout-minutes: 1
      - name: Terraform Plan
        id: TerraformPlan
        run: terraform plan -var-file=tfvars.json -no-color
        timeout-minutes: 1
      - name: Manual Workflow Approval
        uses: trstringer/manual-approval@v1.9.1
        timeout-minutes: 5
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          issue-title: "Terraform Apply to Project ${{ steps.VariablesJson.outputs.Project }} in Env ${{ inputs.Environment }}"
          issue-body: |
            "test"

          additional-approved-words: 'allow'
          additional-denied-words: 'deny'
      - name: Terraform Apply
        run: terraform apply -auto-approve -var-file=tfvars.json
      - name: Terraform Output
        id: TerraformOutput
        run: TerraformOutput=$(terraform output -json | jq -c 'with_entries(.value = .value.value)') ; echo "TerraformOutput=$TerraformOutput" >> $GITHUB_OUTPUT
    outputs:
      TerraformOutput: ${{ steps.TerraformOutput.outputs.TerraformOutput}}
