name: module_terraform
on:
  workflow_call:
    inputs:
      Path:
        required: true
        type: string
      Runner:
        required: false
        type: string
        default: "ubuntu-latest"
      Stage:
        required: true
        type: string
      Environment:
        required: true
        type: string
      ExtraVars:
        required: false
        type: string
        default: "{}"
    outputs:
      TerraformOutput:
        value: ${{ jobs.Terraform.outputs.TerraformOutput }}
        
jobs:

  ParseConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Validate required files
      run: |
        ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
        required_files=(
          main.tf
          providers.tf
          backend.tf
          outputs.tf
          variables.json
          variables.tf
          ./environments/$ENVIRONMENT.tfvars.json
          ./environments/$ENVIRONMENT.tf
        )
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] || { echo "‚ùå Missing required file: $file"; exit 1; }
        done
        echo "‚úÖ All required files are present"
    - name: Validate minimal keys in variables.json
      run: |
        VARIABLES_FILE="variables.json"
        REQUIRED_KEYS=(
          ".CiCd.Project"
          ".CiCd.Repo"
          ".CiCd.Region"
          ".CiCd.Role"
          ".CiCd.BackendBucket"
          ".Project.Network"
          ".Project.Ec2"
        )
        for key in "${REQUIRED_KEYS[@]}"; do
          value=$(jq -r "$key // empty" "$VARIABLES_FILE")
          if [[ -z "$value" || "$value" == "null" ]]; then
            echo "‚ùå ERROR: Missing key $key" ; exit 1
          fi
        done
        echo "‚úÖ All required Keys exists"
    - name: Validate Project, Repo, Stage and Environment format
      run: |
        VARIABLES_FILE="variables.json"
        PROJECT=$(jq -r '.CiCd.Project' "$VARIABLES_FILE")
        REPO=$(jq -r '.CiCd.Repo' "$VARIABLES_FILE")
        ENVIRONMENT="${{ inputs.Environment }}"
        STAGE="${{ inputs.Stage }}"

        # Validar que .CiCd.Project comience con may√∫scula
        if [[ ! "$PROJECT" =~ ^[A-Z] ]]; then
          echo "‚ùå Project must start with a capital letter (actual: \"$PROJECT\")"
          exit 1
        fi

        # Validar que .CiCd.Repo comience con may√∫scula
        if [[ ! "$REPO" =~ ^[A-Z] ]]; then
          echo "‚ùå Repo must start with a capital letter (actual: \"$REPO\")"
          exit 1
        fi

        # Validar que Environment sea solo "Prod" o "Dev"
        if [[ "$ENVIRONMENT" != "Prod" && "$ENVIRONMENT" != "Dev" ]]; then
          echo "‚ùå Invalid Environment: (actual: \"$ENVIRONMENT\")"
          exit 1
        fi

        # Validar que Stage sea solo "Workload" o "Concept"
        if [[ "$STAGE" != "Workload" && "$STAGE" != "Concept" ]]; then
          echo "‚ùå Invalid Stage: (actual: \"$STAGE\")"
          exit 1
        fi

        echo "‚úÖ Project Name '$PROJECT' is valid"
        echo "‚úÖ Repo Name '$REPO' is valid"
        echo "‚úÖ Environment '$ENVIRONMENT' is valid"
        echo "‚úÖ Stage '$STAGE' is valid"
  ExtractConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Load Project.yml
        id: ProjectJson
        run: |
          VARIABLES_FILE="variables.json"
          PROJECT=$(jq -c '.Project' "$VARIABLES_FILE")
          echo "JSON=$PROJECT" >> $GITHUB_OUTPUT
      - name: Load CiCd Data
        id: CiCdJson
        run: |
          VARIABLES_FILE="variables.json"
          PROJECT=$(jq -r '.CiCd.Project' "$VARIABLES_FILE")
          REPO=$(jq -r '.CiCd.Repo' "$VARIABLES_FILE")
          REGION=$(jq -r '.CiCd.Region' "$VARIABLES_FILE")
          ROLE=$(jq -r '.CiCd.Role' "$VARIABLES_FILE")
          BACKENDBUCKET=$(jq -r '.CiCd.BackendBucket' "$VARIABLES_FILE")
          DEPLOYKEYS=$(jq -c '.CiCd.DeployKeys' "$VARIABLES_FILE")
          echo "PROJECT=$PROJECT" >> $GITHUB_OUTPUT
          echo "REPO=$REPO" >> $GITHUB_OUTPUT
          echo "REGION=$REGION" >> $GITHUB_OUTPUT
          echo "ROLE=$ROLE" >> $GITHUB_OUTPUT
          echo "BACKENDBUCKET=$BACKENDBUCKET" >> $GITHUB_OUTPUT
          echo "DEPLOYKEYS=$DEPLOYKEYS" >> $GITHUB_OUTPUT
    outputs:
      ProjectJson: ${{ steps.ProjectJson.outputs.JSON }}
      Project: ${{ steps.CiCdJson.outputs.PROJECT }}
      Repo: ${{ steps.CiCdJson.outputs.REPO }}
      CiCdRegion: ${{ steps.CiCdJson.outputs.REGION }}
      CiCdRole: ${{ steps.CiCdJson.outputs.ROLE }}
      CiCdBackendBucket: ${{ steps.CiCdJson.outputs.BACKENDBUCKET }}
      CiCdDeployKeys: ${{ steps.CiCdJson.outputs.DEPLOYKEYS }}

  ParseSShKey:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig]
    steps:
      - name: Validate Deploy Keys
        id: LoadDeployKeys
        run: |
          DEPLOYKEYS='${{ needs.ExtractConfig.outputs.CiCdDeployKeys }}'
          mkdir -p deploykeys
          for ENTRY in $(echo "$DEPLOYKEYS" | jq -c 'to_entries[]'); do
            NAME=$(echo "$ENTRY" | jq -r '.key')
            KEY_B64=$(echo "$ENTRY" | jq -r '.value')
            echo "üîç Validating key: $NAME"
            KEY=$(echo "$KEY_B64" | base64 -d 2>/dev/null || true)
            if echo "$KEY" | grep -q "PRIVATE KEY"; then
              echo "‚úÖ $NAME is valid"
              echo "$KEY" > "deploykeys/${NAME}.pem"
              chmod 600 "deploykeys/${NAME}.pem"
            else
              echo "‚ùå $NAME is invalid"
              exit 1
            fi
          done
          echo "üî¢ Found $COUNT valid keys"
      - name: Upload Deploy Keys
        uses: actions/upload-artifact@v4
        with:
          name: DeployKeys
          path: deploykeys/
      - name: Validate Keypairs
        run: |
          KEYPAIRS=$(echo '${{ needs.ExtractConfig.outputs.ProjectJson }}' | jq -r '.Ec2.KeyPairs | keys[]')
          for KEY in $KEYPAIRS; do
            echo "üîë Validando clave: $KEY"
            BASE64_KEY=$(echo '${{ needs.ExtractConfig.outputs.ProjectJson }}' | jq -r ".Ec2.KeyPairs[\"$KEY\"]")
            echo "$BASE64_KEY" | base64 -d > decoded_key 2>/dev/null
            if ssh-keygen -l -f decoded_key >/dev/null 2>&1; then
              echo "‚úÖ $KEY is valid"
            else
              echo "‚ùå $KEY is invalid"
              exit 1
            fi
          done
          rm -f decoded_key

  CreateTfFiles:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig, ParseSShKey]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Generate backend.tfbackend
        run: |
          cat <<EOF > backend.tfbackend
            bucket = "${{ needs.ExtractConfig.outputs.CiCdBackendBucket }}"
            key    = "${{ format('{0}{1}.tfstate', needs.ExtractConfig.outputs.Project, inputs.Stage) }}"
            region = "${{ needs.ExtractConfig.outputs.CiCdRegion }}"
          EOF
      - name: Create empty variables.tfvars.json
        run: echo "{}" > variables.tfvars.json
      - name: Append Project String > variables.tfvars.json
        run: |
          jq --arg Project "${{ steps.CiCdJson.outputs.PROJECT }}" '. + {Project: $Project}' variables.tfvars.json > tmp.json && mv tmp.json variables.tfvars.json
      - name: Append Repo String > variables.tfvars.json
        run: |
          jq --arg Repo "${{ steps.CiCdJson.outputs.REPO }}" '. + {Repo: $Repo}' variables.tfvars.json > tmp.json && mv tmp.json variables.tfvars.json
      - name: Append Stage String > variables.tfvars.json
        run: |
          jq --arg stage "${{ inputs.Stage }}" '. + {Stage: $stage}' variables.tfvars.json > tmp.json && mv tmp.json variables.tfvars.json
      - name: Append variables.json Project > variables.tfvars.json
        run: |
          VARS='${{ needs.ExtractConfig.outputs.ProjectJson }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' variables.tfvars.json <(echo "$VARS") > tmp.json && mv tmp.json variables.tfvars.json
          echo "‚úÖ $added_count variables added from Variables Project to variables.tfvars.json"
      - name: Append environment variables > variables.tfvars.json
        run: |
          ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
          VARS="./environments/$ENVIRONMENT.json"
          added_count=$(jq 'keys | length' "$VARS")
          jq -s '.[0] * .[1]' variables.tfvars.json "$VARS" > tmp.json && mv tmp.json variables.tfvars.json
          echo "‚úÖ $added_count variables added from $VARS to variables.tfvars.json"
      - name: Append inputs.ExtraVars > variables.tfvars.json
        run: |
          VARS='${{ inputs.ExtraVars }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' variables.tfvars.json <(echo "$VARS") > tmp.json && mv tmp.json variables.tfvars.json
          echo "‚úÖ $added_count variables added from inputs.ExtraVars to variables.tfvars.json"
      - name: Upload Terraform config files
        uses: actions/upload-artifact@v4
        with:
          name: TfFiles
          path: |
            backend.tfbackend
            variables.tfvars.json

  Apply:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig, ParseSShKey, CreateTfFiles]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Configure AWS credentials from OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.ExtractConfig.outputs.CiCdRole }}
          aws-region: ${{ needs.ExtractConfig.outputs.CiCdRegion }}
      - name: Download Terraform config files
        uses: actions/download-artifact@v4
        with:
          name: TfFiles
      - name: Download DeployKeys
        uses: actions/download-artifact@v4
        with:
          name: DeployKeys
          path: ./deploykeys
      - name: Read all private keys into env var
        id: read_ssh_keys
        run: |
          KEY_DATA=""
          for f in deploykeys/*.pem; do
            [ -f "$f" ] || continue
            KEY=$(cat "$f")
            KEY_DATA="${KEY_DATA}${KEY}"$'\n\n'
          done
          echo "ALL_SSH_KEYS<<EOF" >> $GITHUB_ENV
          echo "$KEY_DATA" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: Load SSH keys into agent
        if: env.ALL_SSH_KEYS != ''
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.ALL_SSH_KEYS }}
      - name: Terraform Init
        run: terraform init -backend-config=backend.tfbackend
      - name: Terraform Validate
        run: terraform validate
        timeout-minutes: 1
      - name: Terraform Plan
        id: TerraformPlan
        run: terraform plan -var-file=variables.tfvars.json -no-color
        timeout-minutes: 1
      - name: Manual Workflow Approval
        uses: trstringer/manual-approval@v1.9.1
        timeout-minutes: 5
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          issue-title: "Terraform Apply to Project ${{ steps.ProjectJson.outputs.Project }} in Env ${{ inputs.Environment }}"
          issue-body: |
            Plan output:

            ```
            ${{ steps.TerraformPlan.outputs.stdout }} 
            
            ```
          additional-approved-words: 'allow'
          additional-denied-words: 'deny'
      - name: Terraform Apply
        run: terraform apply -auto-approve -var-file=variables.tfvars.json
      - name: Terraform Output
        id: TerraformOutput
        run: TerraformOutput=$(terraform output -json | jq -c 'with_entries(.value = .value.value)') ; echo "TerraformOutput=$TerraformOutput" >> $GITHUB_OUTPUT
    outputs:
      TerraformOutput: ${{ steps.TerraformOutput.outputs.TerraformOutput}}
