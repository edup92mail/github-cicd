name: module_terraform
on:
  workflow_call:
    inputs:
      Path:
        required: true
        type: string
      Stage:
        required: true
        type: string
      Environment:
        required: true
        type: string
      ExtraVars:
        required: false
        type: string
        default: "{}"
    outputs:
      TerraformOutput:
        value: ${{ jobs.Terraform.outputs.TerraformOutput }}
        
jobs:

  ParseConfig:
    runs-on: "ubuntu-latest"
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Validate required files
      run: |
        ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
        STAGE=$(echo "${{ inputs.Stage }}" | tr '[:upper:]' '[:lower:]')
        required_files=(
          main.tf
          providers.tf
          backend.tf
          outputs.tf
          cicd.json
          variables.tf
          ./stages/$STAGE.json
          ./environments/$ENVIRONMENT.tfvars.json
          ./environments/$ENVIRONMENT.tf
        )
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] || { echo "‚ùå Missing required file: $file"; exit 1; }
        done
        echo "‚úÖ All required files are present"
    - name: Validate minimal keys in cicd.json
      run: |
        VARIABLES_FILE="cicd.json"
        REQUIRED_KEYS=(
          ".Project"
          ".Region"
          ".Role"
          ".BackendBucket"
        )
        for key in "${REQUIRED_KEYS[@]}"; do
          value=$(jq -r "$key // empty" "$VARIABLES_FILE")
          if [[ -z "$value" || "$value" == "null" ]]; then
            echo "‚ùå ERROR: Missing key $key" ; exit 1
          fi
        done
        echo "‚úÖ All required Keys exists"
    - name: Validate minimal keys in $Stage.json
      run: |
        STAGE=$(echo "${{ inputs.Stage }}" | tr '[:upper:]' '[:lower:]')
        VARIABLES_FILE="./stages/$STAGE.json"
        REQUIRED_KEYS=(
          ".Network"
          ".Ec2"
        )
        for key in "${REQUIRED_KEYS[@]}"; do
          value=$(jq -r "$key // empty" "$VARIABLES_FILE")
          if [[ -z "$value" || "$value" == "null" ]]; then
            echo "‚ùå ERROR: Missing key $key" ; exit 1
          fi
        done
        echo "‚úÖ All required Keys exists"
    - name: Validate Project, Repo, Stage and Environment format
      run: |
        VARIABLES_FILE="cicd.json"
        PROJECT=$(jq -r '.Project' "$VARIABLES_FILE")
        ENVIRONMENT="${{ inputs.Environment }}"
        STAGE="${{ inputs.Stage }}"

        # Validar que .Project comience con may√∫scula
        if [[ ! "$PROJECT" =~ ^[A-Z] ]]; then
          echo "‚ùå PROJECT must start with a capital letter (actual: \"$PROJECT\")"
          exit 1
        fi

        # Validar que Environment sea solo "Prod" o "Dev"
        if [[ "$ENVIRONMENT" != "Prod" && "$ENVIRONMENT" != "Dev" ]]; then
          echo "‚ùå Invalid Environment: (actual: \"$ENVIRONMENT\")"
          exit 1
        fi

        # Validar que Stage comience con may√∫scula
        if [[ ! "$STAGE" =~ ^[A-Z] ]]; then
          echo "‚ùå PROJECT must start with a capital letter (actual: \"$PROJECT\")"
          exit 1
        fi

        echo "‚úÖ Project Name '$PROJECT' is valid"
        echo "‚úÖ Environment '$ENVIRONMENT' is valid"
        echo "‚úÖ Stage '$STAGE' is valid"
  ExtractConfig:
    runs-on: "ubuntu-latest"
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Load CiCd Data
        id: CiCdJson
        run: |
          VARIABLES_FILE="cicd.json"
          PROJECT=$(jq -r '.Project' "$VARIABLES_FILE")
          REGION=$(jq -r '.Region' "$VARIABLES_FILE")
          ROLE=$(jq -r '.Role' "$VARIABLES_FILE")
          BACKENDBUCKET=$(jq -r '.BackendBucket' "$VARIABLES_FILE")
          DEPLOYKEYS=$(jq -c '.DeployKeys' "$VARIABLES_FILE")
          echo "PROJECT=$PROJECT" >> $GITHUB_OUTPUT
          echo "REPO=$REPO" >> $GITHUB_OUTPUT
          echo "REGION=$REGION" >> $GITHUB_OUTPUT
          echo "ROLE=$ROLE" >> $GITHUB_OUTPUT
          echo "BACKENDBUCKET=$BACKENDBUCKET" >> $GITHUB_OUTPUT
          echo "DEPLOYKEYS=$DEPLOYKEYS" >> $GITHUB_OUTPUT
      - name: Load $Stage.json
        id: StageJson
        run: |
          STAGE=$(echo "${{ inputs.Stage }}" | tr '[:upper:]' '[:lower:]')
          VARIABLES_FILE="./stages/$STAGE.json"
          JSON=$(jq -c '.' "$VARIABLES_FILE")
          echo "JSON=$JSON" >> $GITHUB_OUTPUT
    outputs:
      StageJson: ${{ steps.StageJson.outputs.JSON }}
      Project: ${{ steps.CiCdJson.outputs.PROJECT }}
      CiCdRegion: ${{ steps.CiCdJson.outputs.REGION }}
      CiCdRole: ${{ steps.CiCdJson.outputs.ROLE }}
      CiCdBackendBucket: ${{ steps.CiCdJson.outputs.BACKENDBUCKET }}
      CiCdDeployKeys: ${{ steps.CiCdJson.outputs.DEPLOYKEYS }}

  ParseSShKey:
    runs-on: "ubuntu-latest"
    permissions:
      contents: read
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig]
    steps:
      - name: Validate Deploy Keys
        id: LoadDeployKeys
        run: |
          DEPLOYKEYS='${{ needs.ExtractConfig.outputs.CiCdDeployKeys }}'
          mkdir -p deploykeys
          for ENTRY in $(echo "$DEPLOYKEYS" | jq -c 'to_entries[]'); do
            NAME=$(echo "$ENTRY" | jq -r '.key')
            KEY_B64=$(echo "$ENTRY" | jq -r '.value')
            echo "üîç Validating key: $NAME"
            KEY=$(echo "$KEY_B64" | base64 -d 2>/dev/null || true)
            if echo "$KEY" | grep -q "PRIVATE KEY"; then
              echo "‚úÖ $NAME is valid"
              echo "$KEY" > "deploykeys/${NAME}.pem"
              chmod 600 "deploykeys/${NAME}.pem"
            else
              echo "‚ùå $NAME is invalid"
              exit 1
            fi
          done
          echo "üî¢ Found $COUNT valid keys"
      - name: Upload Deploy Keys
        uses: actions/upload-artifact@v4
        with:
          name: DeployKeys
          path: deploykeys/
      - name: Validate Keypairs
        run: |
          KEYPAIRS=$(echo '${{ needs.ExtractConfig.outputs.StageJson }}' | jq -r '.Ec2.KeyPairs | keys[]')
          for KEY in $KEYPAIRS; do
            echo "üîë Validando clave: $KEY"
            BASE64_KEY=$(echo '${{ needs.ExtractConfig.outputs.StageJson }}' | jq -r ".Ec2.KeyPairs[\"$KEY\"]")
            echo "$BASE64_KEY" | base64 -d > decoded_key 2>/dev/null
            if ssh-keygen -l -f decoded_key >/dev/null 2>&1; then
              echo "‚úÖ $KEY is valid"
            else
              echo "‚ùå $KEY is invalid"
              exit 1
            fi
          done
          rm -f decoded_key

  CreateTfFiles:
    runs-on: "ubuntu-latest"
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig, ParseSShKey]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Generate backend.tfbackend
        run: |
          cat <<EOF > backend.tfbackend
            bucket = "${{ needs.ExtractConfig.outputs.CiCdBackendBucket }}"
            key    = "${{ format('{0}{1}.tfstate', needs.ExtractConfig.outputs.Project, inputs.Stage) }}"
            region = "${{ needs.ExtractConfig.outputs.CiCdRegion }}"
          EOF
      - name: Create empty tfvars.json
        run: echo "{}" > tfvars.json
      - name: Append Project Name String > tfvars.json
        run: |
          jq --arg PROJECT "${{ needs.ExtractConfig.outputs.Project }}" '.Tags += {Project: $PROJECT}' tfvars.json > tmp.json && mv tmp.json tfvars.json
      - name: Append Repo String > tfvars.json
        run: |
          jq --arg Repo "$(basename "$GITHUB_REPOSITORY")" '.Tags += {Repo: $Repo}' tfvars.json > tmp.json && mv tmp.json tfvars.json
      - name: Append Stage String > tfvars.json
        run: |
          jq --arg stage "${{ inputs.Stage }}" '.Tags += {Stage: $stage}' tfvars.json > tmp.json && mv tmp.json tfvars.json
      - name: Append $stage.json > tfvars.json
        run: |
          VARS='${{ needs.ExtractConfig.outputs.StageJson }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' tfvars.json <(echo "$VARS") > tmp.json && mv tmp.json tfvars.json
          echo "‚úÖ $added_count variables added from Variables Project to tfvars.json"
      - name: Append environment variables > tfvars.json
        run: |
          ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
          VARS="./environments/$ENVIRONMENT.tfvars.json"
          added_count=$(jq 'keys | length' "$VARS")
          jq -s '.[0] * .[1]' tfvars.json "$VARS" > tmp.json && mv tmp.json tfvars.json
          echo "‚úÖ $added_count variables added from $VARS to tfvars.json"
      - name: Append ENVIRONMENT.tf to root variables.tf
        run: |
          ENVIRONMENT=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
          VAR_FILE="./environments/${ENVIRONMENT}.tf"
          TARGET_FILE="variables.tf"
          echo "‚úÖ Appending $VAR_FILE to $TARGET_FILE"
          echo -e "\n\n" >> "$TARGET_FILE"
          cat "$VAR_FILE" >> "$TARGET_FILE"
      - name: Append inputs.ExtraVars > tfvars.json
        run: |
          VARS='${{ inputs.ExtraVars }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' tfvars.json <(echo "$VARS") > tmp.json && mv tmp.json tfvars.json
          echo "‚úÖ $added_count variables added from inputs.ExtraVars to tfvars.json"
      - name: Upload Terraform config files
        uses: actions/upload-artifact@v4
        with:
          name: TfFiles
          path: |
            backend.tfbackend
            tfvars.json
            variables.tf

  Apply:
    runs-on: "ubuntu-latest"
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ParseConfig, ExtractConfig, ParseSShKey, CreateTfFiles]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Configure AWS credentials from OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.ExtractConfig.outputs.CiCdRole }}
          aws-region: ${{ needs.ExtractConfig.outputs.CiCdRegion }}
      - name: Download Terraform config files
        uses: actions/download-artifact@v4
        with:
          name: TfFiles
      - name: Download DeployKeys
        uses: actions/download-artifact@v4
        with:
          name: DeployKeys
          path: ./deploykeys
      - name: Read all private keys into env var
        id: read_ssh_keys
        run: |
          KEY_DATA=""
          for f in deploykeys/*.pem; do
            [ -f "$f" ] || continue
            KEY=$(cat "$f")
            KEY_DATA="${KEY_DATA}${KEY}"$'\n\n'
          done
          echo "ALL_SSH_KEYS<<EOF" >> $GITHUB_ENV
          echo "$KEY_DATA" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      - name: Load SSH keys into agent
        if: env.ALL_SSH_KEYS != ''
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.ALL_SSH_KEYS }}
      - name: Terraform Init
        run: terraform init -backend-config=backend.tfbackend
      - name: Terraform Validate
        run: terraform validate
        timeout-minutes: 1
      - name: Terraform Plan
        id: TerraformPlan
        run: terraform plan -var-file=tfvars.json -no-color -input=false -detailed-exitcode -out=plan.tfplan
        timeout-minutes: 1
      - name: Terraform diff
        id: TerraformDiff
        run: |
          echo "diff<<EOF" >> $GITHUB_OUTPUT
          terraform show -no-color plan.tfplan >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Send Approbal to Slack and Wait for response
        env:
          SLACK_TOKEN: "xoxb-9033139688231-9051357383573-5OpQ2bQKazhd2wXtxWIjmHGE"
          CHANNEL_ID: "C0923CDTJFJ"
          PROJECT: ${{ needs.ExtractConfig.outputs.Project }}
          REPO: ${{ github.repository }}
          ENVIRONMENT: ${{ inputs.Environment }}
          STAGE: ${{ inputs.Stage }}
          TFDIFF: ${{ steps.TerraformDiff.outputs.diff }}
          RUN_URL: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        run: |

          # Post message to Slack

          CICDMESSAGE=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
              --data "{\"channel\":\"$CHANNEL_ID\",\"text\":\"Resumen del diff de Terraform\",\"blocks\":[{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":$ESCAPED_DIFF}}]}")
          )

          echo "üîç CICDMESSAGE (respuesta de Slack):"
          echo "$CICDMESSAGE" | jq .

          THREAD_TS=$(echo "$CICDMESSAGE" | jq -r '.ts')

          if [[ -z "$THREAD_TS" || "$THREAD_TS" == "null" ]]; then
            echo "‚ùå Cant find thread_ts"
            exit 1
          fi

          for i in {1..60}; do

            echo "‚åõ Waiting for approbal"
            sleep 3

            RESPONSES=$(curl -s -G "https://slack.com/api/conversations.replies" \
              -H "Authorization: Bearer $SLACK_TOKEN" \
              --data-urlencode "channel=$CHANNEL_ID" \
              --data-urlencode "ts=$THREAD_TS")

            if echo "$RESPONSES" | jq -r '.messages[]?.text' | grep -i -q '^ok$'; then
              echo "üü¢ Got Approbal"

              curl -s -X POST "https://slack.com/api/chat.postMessage" \
                -H "Authorization: Bearer $SLACK_TOKEN" \
                -H "Content-Type: application/json; charset=utf-8" \
                --data '{
                  "channel": "'"$CHANNEL_ID"'",
                  "thread_ts": "'"$THREAD_TS"'",
                  "text": "@everyone ‚è∞ *Got Approbal, Job continues*"
                }' > /dev/null

              exit 0
            fi
          done

          echo "‚è∞ Approbal Timeout"

          curl -s -X POST "https://slack.com/api/chat.postMessage" \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
            --data '{
              "channel": "'"$CHANNEL_ID"'",
              "thread_ts": "'"$THREAD_TS"'",
              "text": "@everyone ‚è∞ *Approbal Timeout, Job cancelled*"
            }' > /dev/null

          exit 1
      - name: Test
        run: echo "ok"