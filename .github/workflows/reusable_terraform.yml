name: module_terraform
on:
  workflow_call:
    inputs:
      Path:
        required: true
        type: string
      Runner:
        required: false
        type: string
        default: "ubuntu-latest"
      Environment:
        required: true
        type: string
      ExtraVars:
        required: false
        type: string
        default: "{}"
    outputs:
      TerraformOutput:
        value: ${{ jobs.Terraform.outputs.TerraformOutput }}
        
jobs:

  Checks:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Validate required files
      run: |
        environment=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
        required_files=(
          main.tf backend.tf providers.tf data.tf variables.tf outputs.tf
          ./config/deploy.yml ./config/product.yml ./config/env/$environment.yml
        )
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] || { echo "‚ùå Missing required file: $file"; exit 1; }
        done
        echo "‚úÖ All required files are present"
    - name: Validate minimal keys in product config
      run: |
        for key in Product Network Ec2; do
          grep -qE "^[[:space:]]*${key}:" ./config/product.yml \
            && echo "‚úÖ Key '$key' exists" \
            || { echo "‚ùå ERROR: Missing key '$key'"; exit 1; }
        done
    - name: Validate Product and Environment format
      run: |
        product=$(yq e '.Product' ./config/product.yml)
        [[ "$product" =~ ^[A-Z] ]] || { echo "‚ùå Product must start with a capital letter (Found: '$product')"; exit 1; }
        case "${{ inputs.Environment }}" in
          Prod|Dev) echo "‚úÖ Environment '${{ inputs.Environment }}' is valid" ;;
          *) echo "‚ùå Invalid Environment: ${{ inputs.Environment }}"; exit 1 ;;
        esac
        echo "‚úÖ Product '$product' is valid"
        
  Terraform:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [Checks]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Terraform Install
        uses: hashicorp/setup-terraform@v3

      - name: Extract deploy variables
        id: LoadDeployYml
        run: |
          f=./config/deploy.yml
      
          # extrae y valida valores simples
          CiCdRoleArn=$(yq e -r '.DeployCiCdRoleArn' "$f")
          BackendBucket=$(yq e -r '.BackendBucket'       "$f")
          Region=$(yq e -r '.Region'                    "$f")
          for var in CiCdRoleArn BackendBucket Region; do
            val=${!var}
            [[ -n $val && $val != "null" ]] || { echo "‚ùå $var not found in $f"; exit 1; }
            echo "$var=$val" >> $GITHUB_OUTPUT
          done
      
          # extrae y valida la key base64 (√∫nico campo Modules)
          key=$(yq e -r '.DeployKeys.Modules' "$f")
          [[ -n $key && $key != "null" ]] || { echo "‚ùå DeployKeys.Modules not found in $f"; exit 1; }
      
          # usa sintaxis de m√∫ltiples l√≠neas para GITHUB_OUTPUT
          echo "DeployKeys<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$key" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
          echo "‚úÖ All required deploy variables exist"

      - name: KeyPairs Check
        run: |
          f=./config/product.yml; p='.Ec2.KeyPairs'
          # Asegura que haya al menos una KeyPair
          (( $(yq e "$p|length" $f) )) || { echo "‚ùå No se encontr√≥ ninguna KeyPair"; exit 1; }
          # Para cada clave, decodifica base64 y p√°sala a ssh-keygen
          for k in $(yq e "$p|keys|.[]" $f); do
            echo "üîç $k"
            ssh-keygen -l -f <(yq e "$p.\"$k\"" $f | base64 -d) \
              && echo "‚úîÔ∏è $k OK" || { echo "üö´ $k ERROR"; exit 1; }
          done
          echo "‚úÖ Todas las KeyPairs v√°lidas"
      - name: Load DeployKeys from ./config/deploy.yml
        id: LoadDeployKeys
        run: |
          # Cuenta cu√°ntas DeployKeys hay
          c=$(yq e '.DeployKeys|length' ./config/deploy.yml)
          echo "ssh_key_count=$c" >> $GITHUB_OUTPUT

          # Si hay al menos una, decodifica todo de golpe
          if (( c > 0 )); then
            data=$(yq e -r '.DeployKeys[]' ./config/deploy.yml | base64 -d)

            # Enmascara y exporta
            echo "::add-mask::$data"
            {
              echo "ALL_SSH_KEYS<<EOF"
              printf '%s\n' "$data"
              echo "EOF"
            } >> $GITHUB_ENV

            echo "‚úÖ $c claves SSH cargadas"
          else
            echo "‚ö†Ô∏è No se encontraron DeployKeys"
          fi
      - name: Load DeployKeys in Runner if exists
        if: steps.LoadDeployKeys.outputs.ssh_key_count != '0'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.ALL_SSH_KEYS }}
      - name: Create backend Tfbackend
        run: |
          cat <<EOF > backend.tfbackend
            bucket = "${{ steps.LoadDeployYml.outputs.BackendBucket }}"
            key = "{{ steps.LoadDeployYml.outputs.Product }}-${{ inputs.Environment}}.tfstate"
            region = "${{ steps.LoadDeployYml.outputs.Region }}"
          EOF
      - name: Create empty vars.json
        run: echo "{}" > vars.json
      - name: Append inputs.ExtraVars > vars.json
        run: |
          extra_vars='${{ inputs.ExtraVars }}'
          added_count=$(echo "$extra_vars" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(echo "$extra_vars") > tmp.json && mv tmp.json vars.json
          echo "‚úÖ $added_count variables added from inputs.ExtraVars to vars.json"

      - name: Append Product object > vars.json
        run: |
          product_name=$(yq e -r '.Product' ./config/product.yml)
          env="${{ inputs.Environment }}"
          jq --arg name "$product_name" --arg env "$env" \
            '.Product = { Name: $name, Environment: $env }' \
            vars.json > tmp.json && mv tmp.json vars.json
          echo "‚úÖ Product object added: Name=$product_name, Environment=$env"
      - name: Append environment variables > vars.json
        run: |
          env_file="./config/env/$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]').yml"
          added_count=$(yq -o=json "$env_file" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(yq -o=json "$env_file") > tmp.json && mv tmp.json vars.json
          echo "‚úÖ $added_count variables added from $env_file to vars.json"
      - name: Append inputs.ExtraVars > vars.json
        run: |
          extra_vars='${{ inputs.ExtraVars }}'
          added_count=$(echo "$extra_vars" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(echo "$extra_vars") > tmp.json && mv tmp.json vars.json
          echo "‚úÖ $added_count variables added from inputs.ExtraVars to vars.json"
      - name: Configure AWS credentials from OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.LoadDeployYml.outputs.CiCdRoleArn }}
          aws-region: ${{ steps.LoadDeployYml.outputs.Region }}
      - name: Terraform Init
        run: terraform init -backend-config=backend.tfbackend
      - name: Terraform Validate
        run: terraform validate
      - name: Terraform Plan
        id: TerraformPlan
        run: terraform plan -var-file=vars.json -no-color
        timeout-minutes: 1
      - name: Manual Workflow Approval
        uses: trstringer/manual-approval@v1.9.1
        timeout-minutes: 5
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          issue-title: "Terraform Apply to Product ${{ steps.LoadProductYml.outputs.Product }} in Env ${{ inputs.Environment }}"
          issue-body: |
            Plan output:

            ```
            ${{ steps.TerraformPlan.outputs.stdout }} 
            
            ```
          additional-approved-words: 'allow'
          additional-denied-words: 'deny'
      - name: Terraform Apply
        run: terraform apply -auto-approve -var-file=vars.json
      - name: Terraform Output
        id: TerraformOutput
        run: TerraformOutput=$(terraform output -json | jq -c 'with_entries(.value = .value.value)') ; echo "TerraformOutput=$TerraformOutput" >> $GITHUB_OUTPUT
    outputs:
      TerraformOutput: ${{ steps.TerraformOutput.outputs.TerraformOutput}}
