name: module_terraform
on:
  workflow_call:
    inputs:
      Path:
        required: true
        type: string
      Runner:
        required: false
        type: string
        default: "ubuntu-latest"
      Environment:
        required: true
        type: string
      ExtraVars:
        required: false
        type: string
        default: "{}"
    outputs:
      TerraformOutput:
        value: ${{ jobs.Terraform.outputs.TerraformOutput }}
        
jobs:

  ValidateConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Validate required files
      run: |
        environment=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
        required_files=(
          main.tf backend.tf providers.tf data.tf variables.tf outputs.tf
          ./config/cicd.yml ./config/product.yml ./config/env/$environment.yml
        )
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] || { echo "âŒ Missing required file: $file"; exit 1; }
        done
        echo "âœ… All required files are present"
    - name: Validate minimal keys in product.yml
      run: |
        for key in Product Region Role BackendBucket Network Ec2; do
          grep -qE "^[[:space:]]*${key}:" ./config/product.yml \
            && echo "âœ… Key '$key' exists" \
            || { echo "âŒ ERROR: Missing key '$key'"; exit 1; }
        done
    - name: Validate minimal keys in cicd.yml
      run: |
        for key in Region Role BackendBucket; do
          grep -qE "^[[:space:]]*${key}:" ./config/cicd.yml \
            && echo "âœ… Key '$key' exists" \
            || { echo "âŒ ERROR: Missing key '$key'"; exit 1; }
        done
    - name: Validate Product and Environment format
      run: |
        product=$(yq e '.Product' ./config/product.yml)
        [[ "$product" =~ ^[A-Z] ]] || { echo "âŒ Product must start with a capital letter (Found: '$product')"; exit 1; }
        case "${{ inputs.Environment }}" in
          Prod|Dev) echo "âœ… Environment '${{ inputs.Environment }}' is valid" ;;
          *) echo "âŒ Invalid Environment: ${{ inputs.Environment }}"; exit 1 ;;
        esac
        echo "âœ… Product '$product' is valid"

  ExtractConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ValidateConfig]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Load product.yml
        id: ProductYml
        run: |
          CONTENT=$(yq e -o=json ./config/product.yml | jq -c .)
          echo "Yml=$CONTENT" >> "$GITHUB_OUTPUT"
      - name: Load cicd.yml
        id: CiCdYml
        run: |
          CONTENT=$(yq e -o=json ./config/cicd.yml | jq -c .)
          echo "Yml=$CONTENT" >> "$GITHUB_OUTPUT"
    outputs:
      ProductYml: ${{ steps.ProductYml.outputs.Yml }}
      CiCdYml: ${{ needs.CiCdYml.outputs.CiCdYml.outputs.Yml }}

  SShKeyJobs:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ValidateConfig, ExtractConfig]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Aws KeyPairs Check
        run: |
          jq -r '.Ec2.KeyPairs // {} | to_entries[]' <<<"${{ needs.ExtractConfig.outputs.ProductYml.outputs.Yml }}" | while read -r entry; do
            key=$(jq -r '.key' <<<"$entry")
            val=$(jq -r '.value' <<<"$entry")
            echo "ðŸ” $key"
            echo "$val" | base64 -d | ssh-keygen -l -f /dev/stdin \
              && echo "âœ”ï¸ $key OK" || { echo "ðŸš« $key ERROR"; exit 1; }
          done || { echo "âŒ No se encontrÃ³ ninguna KeyPair"; exit 1; }
          echo "âœ… Todas las KeyPairs vÃ¡lidas"
      - name: Github DeployKeys Load
        run: |
          CONFIG='${{ needs.ExtractConfig.outputs.CiCdYml.outputs.Yml }}'
          COUNT=0; VALID_KEYS=""
          jq -r '.DeployKeys // {} | to_entries[] | "\(.key):::\(.value)"' <<< "$CONFIG" | while IFS=':::' read -r name block; do
            while read -r line; do
              [[ -z "$line" ]] && continue
              key=$(echo "$line" | base64 -d 2>/dev/null) || { echo "âŒ Decode error in $name"; exit 1; }
              echo "$key" | ssh-keygen -l -f /dev/stdin &>/dev/null || { echo "ðŸš« Invalid key in $name"; exit 1; }
              echo "::add-mask::$key"
              VALID_KEYS+="$key"$'\n'; ((COUNT++))
            done <<< "$block"
          done
          echo -e "ALL_SSH_KEYS<<EOF\n$VALID_KEYS\nEOF" >> "$GITHUB_ENV"
          echo "ssh_key_count=$COUNT" >> "$GITHUB_OUTPUT"
          echo "âœ… $COUNT claves SSH vÃ¡lidas desde DeployKeys.*"
      - name: Load DeployKeys in Runner if exists
        if: steps.LoadDeployKeys.outputs.ssh_key_count != '0'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.ALL_SSH_KEYS }}

  CreateTfFiles:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ValidateConfig, ExtractConfig, SShKeyJobs]
    steps:
      - name: Generate backend.tfbackend
        run: |
          CiCdYml='${{ needs.ExtractConfig.outputs.CiCdYml.outputs.Yml }}'
          cat <<EOF > backend.tfbackend
            bucket = "$(jq -r '.BackendBucket' <<< "$CiCdYml")"
            key    = "$(jq -r '.Product' <<< "$CiCdYml")-${{ inputs.Environment }}.tfstate"
            region = "$(jq -r '.Region' <<< "$CiCdYml")"
          EOF
      - name: Create empty vars.json
        run: echo "{}" > vars.json
      - name: Append inputs.ExtraVars > vars.json
        run: |
          Vars='${{ inputs.ExtraVars }}'
          added_count=$(echo "$Vars" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(echo "$Vars") > tmp.json && mv tmp.json vars.json
          echo "âœ… $added_count variables added from inputs.ExtraVars to vars.json"
      - name: Append Product object > vars.json
        run: |
          Vars='${{ needs.ExtractConfig.outputs.ProductYml.outputs.Yml }}'
          added_count=$(echo "$Vars" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(echo "$Vars") > tmp.json && mv tmp.json vars.json
          echo "âœ… $added_count variables added from iProductYml to vars.json"
      - name: Append environment variables > vars.json
        run: |
          Vars="./config/env/$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]').yml"
          added_count=$(yq -o=json "$Vars" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(yq -o=json "$Vars") > tmp.json && mv tmp.json vars.json
          echo "âœ… $added_count variables added from $env_file to vars.json"

  Terraform:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ValidateConfig, ExtractConfig, SShKeyJobs, CreateTfFiles]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Extract AWS Config from CiCdYml
        id: AwsVars
        run: |
          CONFIG='${{ needs.ExtractConfig.outputs.CiCdYml.outputs.Yml }}'
          ROLE=$(jq -r '.Role' <<< "$CONFIG")
          REGION=$(jq -r '.Region' <<< "$CONFIG")
          echo "ROLE=$ROLE" >> $GITHUB_OUTPUT
          echo "REGION=$REGION" >> $GITHUB_OUTPUT
      - name: Configure AWS credentials from OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.AwsVars.outputs.ROLE }}
          aws-region: ${{ steps.AwsVars.outputs.REGION }}
      - name: Terraform Init
        run: terraform init -backend-config=backend.tfbackend
      - name: Terraform Validate
        run: terraform validate
      - name: Terraform Plan
        id: TerraformPlan
        run: terraform plan -var-file=vars.json -no-color
        timeout-minutes: 1
      - name: Manual Workflow Approval
        uses: trstringer/manual-approval@v1.9.1
        timeout-minutes: 5
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          issue-title: "Terraform Apply to Product ${{ steps.ProductYml.outputs.Product }} in Env ${{ inputs.Environment }}"
          issue-body: |
            Plan output:

            ```
            ${{ steps.TerraformPlan.outputs.stdout }} 
            
            ```
          additional-approved-words: 'allow'
          additional-denied-words: 'deny'
      - name: Terraform Apply
        run: terraform apply -auto-approve -var-file=vars.json
      - name: Terraform Output
        id: TerraformOutput
        run: TerraformOutput=$(terraform output -json | jq -c 'with_entries(.value = .value.value)') ; echo "TerraformOutput=$TerraformOutput" >> $GITHUB_OUTPUT
    outputs:
      TerraformOutput: ${{ steps.TerraformOutput.outputs.TerraformOutput}}
