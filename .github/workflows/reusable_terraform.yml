name: module_terraform
on:
  workflow_call:
    inputs:
      Path:
        required: true
        type: string
      Runner:
        required: false
        type: string
        default: "ubuntu-latest"
      Environment:
        required: true
        type: string
      ExtraVars:
        required: false
        type: string
        default: "{}"
    outputs:
      TerraformOutput:
        value: ${{ jobs.job.outputs.TerraformOutput }}
        
jobs:
  Terraform:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Terraform Install
        uses: hashicorp/setup-terraform@v3
      - name: Required Files check
        run: |
          environment=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
          terraform_files=("main.tf" "backend.tf" "providers.tf" "data.tf" "variables.tf" "outputs.tf")
          config_files=("./config/aws.yml" "./config/product.yml" "./config/env/$environment.yml")
          required_directories=("./config/deploykeys" "./config/keypairs")
          for file in "${terraform_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "Error: Required Terraform file not found: $file"
              exit 1
            fi
          done
          for file in "${config_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "Error: Required config file not found: $file"
              exit 1
            fi
          done
          for dir in "${required_directories[@]}"; do
            if [ ! -d "$dir" ]; then
              echo "Error: Required directory not found: $dir"
              exit 1
            fi
          done
          echo "‚úÖ All minimium Files files exists"
      - name: Extract ./config/aws.yml
        id: LoadAwsYml
        run: |
          CiCdRoleArn=$(yq '.CiCdRoleArn' ./config/aws.yml)
          BackendBucket=$(yq '.BackendBucket' ./config/aws.yml)
          Region=$(yq '.Region' ./config/aws.yml)
          echo "CiCdRoleArn=$CiCdRoleArn" >> $GITHUB_OUTPUT
          echo "BackendBucket=$BackendBucket" >> $GITHUB_OUTPUT
          echo "Region=$Region" >> $GITHUB_OUTPUT
          if [ -z "$CiCdRoleArn" ] || [ "$CiCdRoleArn" = "null" ] || \
            [ -z "$BackendBucket" ] || [ "$BackendBucket" = "null" ] || \
            [ -z "$Region" ] || [ "$Region" = "null" ]; then
            echo "‚ùå Required AWS variable in ./config/aws.yml not found"
            exit 1
          fi
          echo "‚úÖ All minimium Aws variables exists"
      - name: Extract ./config/product.yml
        id: LoadProductYml
        run: |
          product=$(yq '.Product' ./config/product.yml)
          echo "Product=$product" >> $GITHUB_OUTPUT
          if [ -z "$product" ] || [ "$product" = "null" ]; then
            echo "‚ùå Required Product Name variable not found in ./config/product.yml"
            exit 1
          fi
          echo "‚úÖ All minimium Product variables exists"
      - name: Product and Environment Style Check
        run: |
          if ! [[ "${{ steps.LoadProductYml.outputs.Product }}" =~ ^[A-Z] ]]; then
            echo "‚ùå Product debe comenzar con una letra may√∫scula (A-Z)."
            exit 1
          fi
          if [[ "${{ inputs.Environment }}" != "Prod" && "${{ inputs.Environment }}" != "Dev" ]]; then
            echo "‚ùå Invalid Environment: ${{ inputs.Environment }}"
            exit 1
          fi
          echo "‚úÖ Product and Environment names Passed"
      - name: KeyPairs Check
        run: |

          KEYPAIRS=(./config/keypairs/*)
          
          if (( ${#KEYPAIRS[@]} == 0 )); then
            echo "‚ùå No se encontr√≥ ninguna KeyPair en ./config/keypairs"
            exit 1
          fi

          for keyfile in "${KEYPAIRS[@]}"; do
            echo "üîç Comprobando $keyfile..."
            if ssh-keygen -l -f "$keyfile" &>/dev/null; then
              echo "‚úîÔ∏è  $keyfile: Public Key OK"
            else
              echo "üö´ $keyfile: Public Key ERROR" >&2
              exit 1
            fi
          done
          
          echo "‚úÖ Todas las KeyPairs tienen formato correcto."
      - name: Extract ./config/deploykeys/*
        id: LoadDeployKeys
        run: |
          count=0
          key_block=""
          loaded_keys=()
          for keyfile in ./config/deploykeys/*.pem; do
            [ -e "$keyfile" ] || continue
            key_name=$(basename "$keyfile")
            key_content=$(cat "$keyfile")
            echo "::add-mask::$key_content"
            key_block="${key_block}${key_content}"$'\n'
            loaded_keys+=("$key_name")
            count=$((count + 1))
          done
          echo "ssh_key_count=$count" >> $GITHUB_OUTPUT
          if [ "$count" -gt 0 ]; then
            echo "ALL_SSH_KEYS<<EOF" >> $GITHUB_ENV
            echo "$key_block" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "‚úÖ $count claves SSH cargadas: ${loaded_keys[*]/#/- }"
          else
            echo "‚ö†Ô∏è No se encontraron claves SSH en ./config/deploykeys/"
          fi
      - name: Load ./config/deploykeys/* in Runner if exists
        if: steps.LoadDeployKeys.outputs.ssh_key_count != '0'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.ALL_SSH_KEYS }}
      - name: Create backend Tfbackend
        run: |
          cat <<EOF > backend.tfbackend
            bucket = "${{ steps.LoadAwsYml.outputs.BackendBucket }}"
            key = "{{ steps.LoadAwsYml.outputs.Product }}-${{ inputs.Environment}}.tfstate"
            region = "${{ steps.LoadAwsYml.outputs.Region }}"
          EOF
      - name: Create empty vars.json
        run: echo "{}" > vars.json
      - name: Append ENV_PRODUCT > vars.json
        run: |
          env_value="${{ inputs.Environment }}"
          product="${{ steps.LoadProductYml.outputs.Product }}"
          jq --arg env "$env_value" --arg name "$product" '.ENV_PRODUCT = { Name: $name, Environment: $env }' vars.json > tmp.json && mv tmp.json vars.json
          echo "‚úÖ ENV_PRODUCT block with Name \"$name\" and Environment \"$env_value\" added to vars.json"
      - name: Append environment variables > vars.json
        run: |
          env_file="./config/env/$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]').yml"
          added_count=$(yq -o=json "$env_file" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(yq -o=json "$env_file") > tmp.json && mv tmp.json vars.json
          echo "‚úÖ $added_count variables added from $env_file to vars.json"
      - name: Append inputs.ExtraVars > vars.json
        run: |
          extra_vars='${{ inputs.ExtraVars }}'
          added_count=$(echo "$extra_vars" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(echo "$extra_vars") > tmp.json && mv tmp.json vars.json
          echo "‚úÖ $added_count variables added from inputs.ExtraVars to vars.json"
      - name: Configure AWS credentials from OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.LoadAwsYml.outputs.CiCdRoleArn }}
          aws-region: ${{ steps.LoadAwsYml.outputs.Region }}
      - name: Terraform Init
        run: terraform init -backend-config=backend.tfbackend
      - name: Terraform Validate
        run: terraform validate
      - name: Terraform Plan
        id: TerraformPlan
        run: terraform plan -var-file=vars.json -no-color
        timeout-minutes: 1
      - name: Manual Workflow Approval
        uses: trstringer/manual-approval@v1.9.1
        timeout-minutes: 5
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          issue-title: "Terraform Apply to Product ${{ steps.LoadProductYml.outputs.Product }} in Env ${{ inputs.Environment }}"
          issue-body: |
            Plan output:

            ```
            ${{ steps.TerraformPlan.outputs.stdout }} 
            
            ```
          additional-approved-words: 'allow'
          additional-denied-words: 'deny'
      - name: Terraform Apply
        run: terraform apply -auto-approve -var-file=vars.json
      - name: Terraform Output
        id: TerraformOutput
        run: JSON=$(terraform output -json | jq -c 'with_entries(.value = .value.value)') ; echo "TerraformOutput=$JSON" >> $GITHUB_OUTPUT
    outputs:
      TerraformOutput: ${{ steps.output.outputs.JSON}}
