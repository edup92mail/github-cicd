name: module_terraform
on:
  workflow_call:
    inputs:
      Path:
        required: true
        type: string
      Runner:
        required: false
        type: string
        default: "ubuntu-latest"
      Environment:
        required: true
        type: string
      ExtraVars:
        required: false
        type: string
        default: "{}"
    outputs:
      TerraformOutput:
        value: ${{ jobs.Terraform.outputs.TerraformOutput }}
        
jobs:

  ValidateConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      id-token: write
      contents: read 
      issues: write
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Validate required files
      run: |
        environment=$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]')
        required_files=(
          main.tf backend.tf providers.tf data.tf variables.tf outputs.tf
          ./config/cicd.yml ./config/product.yml ./config/env/$environment.yml
        )
        for file in "${required_files[@]}"; do
          [[ -f "$file" ]] || { echo "‚ùå Missing required file: $file"; exit 1; }
        done
        echo "‚úÖ All required files are present"
    - name: Validate minimal keys in product.yml
      run: |
        for key in Product Network Ec2; do
          grep -qE "^[[:space:]]*${key}:" ./config/product.yml \
            && echo "‚úÖ Key '$key' exists" \
            || { echo "‚ùå ERROR: Missing key '$key'"; exit 1; }
        done
    - name: Validate minimal keys in cicd.yml
      run: |
        for key in Region Role BackendBucket DeployKeys; do
          grep -qE "^[[:space:]]*${key}:" ./config/cicd.yml \
            && echo "‚úÖ Key '$key' exists" \
            || { echo "‚ùå ERROR: Missing key '$key'"; exit 1; }
        done
    - name: Validate Product and Environment format
      run: |
        product=$(yq e '.Product' ./config/product.yml)
        [[ "$product" =~ ^[A-Z] ]] || { echo "‚ùå Product must start with a capital letter (Found: '$product')"; exit 1; }
        case "${{ inputs.Environment }}" in
          Prod|Dev) echo "‚úÖ Environment '${{ inputs.Environment }}' is valid" ;;
          *) echo "‚ùå Invalid Environment: ${{ inputs.Environment }}"; exit 1 ;;
        esac
        echo "‚úÖ Product '$product' is valid"

  ExtractConfig:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ValidateConfig]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Load product.yml
        id: ProductYml
        run: |
          CONTENT=$(yq e -o=json ./config/product.yml | jq -c .)
          echo "Yml=$CONTENT" >> $GITHUB_OUTPUT
      - name: Load cicd.yml
        id: CiCdYml
        run: |
          CONTENT=$(yq e -o=json ./config/cicd.yml)
          REGION=$(echo "$CONTENT" | jq -r '.Region')
          ROLE=$(echo "$CONTENT" | jq -r '.Role')
          BACKENDBUCKET=$(echo "$CONTENT" | jq -r '.BackendBucket')
          DEPLOYKEYS=$(echo "$CONTENT" | jq -c '.DeployKeys')
          echo "REGION=$REGION" >> $GITHUB_OUTPUT
          echo "ROLE=$ROLE" >> $GITHUB_OUTPUT
          echo "BACKENDBUCKET=$BACKENDBUCKET" >> $GITHUB_OUTPUT
          echo "DEPLOYKEYS=$DEPLOYKEYS" >> $GITHUB_OUTPUT
    outputs:
      ProductYml: ${{ steps.ProductYml.outputs.Yml }}
      CiCdRegion: ${{ steps.CiCdYml.outputs.REGION }}
      CiCdRole: ${{ steps.CiCdYml.outputs.ROLE }}
      CiCdBackendBucket: ${{ steps.CiCdYml.outputs.BACKENDBUCKET }}
      CiCdDeployKeys: ${{ steps.CiCdYml.outputs.DEPLOYKEYS }}

  SShKeyJobs:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ValidateConfig, ExtractConfig]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate and load SSH deploy keys
        id: LoadDeployKeys
        run: |
          DEPLOYKEYS_JSON='${{ needs.ExtractConfig.outputs.CiCdDeployKeys }}'

          COUNT=0
          ALL_KEYS=""

          for ENTRY in $(echo "$DEPLOYKEYS_JSON" | jq -c 'to_entries[]'); do
            NAME=$(echo "$ENTRY" | jq -r '.key')
            KEY_B64=$(echo "$ENTRY" | jq -r '.value')

            echo "üîç Validating key: $NAME"

            KEY=$(echo "$KEY_B64" | base64 -d 2>/dev/null || true)

            if echo "$KEY" | grep -q "PRIVATE KEY"; then
              echo "‚úÖ $NAME is valid"
              ALL_KEYS="${ALL_KEYS}${KEY}"$'\n\n'
              COUNT=$((COUNT + 1))
            else
              echo "‚ùå $NAME is invalid"
              exit 1
            fi
          done

          echo "üî¢ Found $COUNT valid keys"
          echo "ssh_key_count=$COUNT" >> "$GITHUB_OUTPUT"
          echo "ALL_SSH_KEYS<<EOF" >> "$GITHUB_ENV"
          echo "$ALL_KEYS" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
      - name: Load DeployKeys in Runner if exists
        if: steps.LoadDeployKeys.outputs.ssh_key_count != '0'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.ALL_SSH_KEYS }}

  CreateTfFiles:
    runs-on: ${{ inputs.Runner }}
    permissions:
      contents: read 
    defaults:
      run:
        working-directory: ${{ inputs.Path }}
    needs: [ValidateConfig, ExtractConfig, SShKeyJobs]
    steps:
      - name: Generate backend.tfbackend
        run: |
          cat <<EOF > backend.tfbackend
            bucket = "${{ needs.ExtractConfig.outputs.CiCdBackendBucket }}"
            key    = "${{ needs.ExtractConfig.outputs.CiCdBackendBucket }}-${{ inputs.Environment }}.tfstate"
            region = "${{ needs.ExtractConfig.outputs.CiCdRegion }}"
          EOF
      - name: Create empty vars.json
        run: echo "{}" > vars.json
      - name: Append inputs.ExtraVars > vars.json
        run: |
          VARS='${{ inputs.ExtraVars }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(echo "$VARS") > tmp.json && mv tmp.json vars.json
          echo "‚úÖ $added_count variables added from inputs.ExtraVars to vars.json"
      - name: Append Product object > vars.json
        run: |
          VARS='${{ needs.ExtractConfig.outputs.ProductYml }}'
          added_count=$(echo "$VARS" | jq 'keys | length')
          jq -s '.[0] * .[1]' vars.json <(echo "$VARS") > tmp.json && mv tmp.json vars.json
          echo "‚úÖ $added_count variables added from iProductYml to vars.json"
      - name: Append environment variables > vars.json
        run: |
          VARS="./config/env/$(echo "${{ inputs.Environment }}" | tr '[:upper:]' '[:lower:]').yml"

          echo "üîç Loading environment vars from: $VARS"

          if [[ ! -s "$VARS" ]]; then
            echo "‚ö†Ô∏è File $VARS is empty or does not exist"
            exit 1
          fi

          VARS_JSON=$(yq -o=json "$VARS")

          if [[ "$VARS_JSON" == "null" ]]; then
            echo "‚ö†Ô∏è Parsed $VARS is null. Is the YAML empty or incorrect?"
            exit 1
          fi

          added_count=$(echo "$VARS_JSON" | jq 'keys | length')

          jq -s '.[0] * .[1]' vars.json <(echo "$VARS_JSON") > tmp.json && mv tmp.json vars.json

          echo "‚úÖ $added_count variables added from $VARS to vars.json"

